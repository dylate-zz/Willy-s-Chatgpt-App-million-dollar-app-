<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChatGPT Screen to Video Slideshow Maker</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; color: #fff; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; padding: 20px; min-height: 100vh; }
        .container { max-width: 1400px; margin: 0 auto; }
        .header { display: flex; align-items: center; justify-content: center; gap: 15px; margin-bottom: 40px; }
        .logo { width: 32px; height: 32px; fill: white; }
        h1 { font-size: 28px; font-weight: 600; }
        .tabs { display: flex; gap: 10px; margin-bottom: 20px; border-bottom: 2px solid #565869; }
        .tab { padding: 12px 24px; background: transparent; color: #fff; border: none; cursor: pointer; font-size: 16px; font-weight: 500; border-bottom: 3px solid transparent; transition: all 0.2s; }
        .tab:hover { background: #40414f; }
        .tab.active { border-bottom-color: #10a37f; color: #10a37f; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .main-grid { display: grid; grid-template-columns: 2fr 1fr; gap: 20px; }
        .card { background: #444654; border: 1px solid #565869; border-radius: 12px; padding: 24px; margin-bottom: 20px; }
        .card h2 { font-size: 18px; font-weight: 600; margin-bottom: 16px; }
        .upload-area { border: 2px dashed #565869; border-radius: 8px; padding: 40px; text-align: center; cursor: pointer; transition: background 0.2s; }
        .upload-area:hover { background: #40414f; }
        .upload-icon { width: 48px; height: 48px; margin: 0 auto 12px; }
        input[type="file"] { display: none; }
        .slides-list { max-height: 500px; overflow-y: auto; }
        .slide-item { background: #343541; border: 1px solid #565869; border-radius: 8px; padding: 16px; margin-bottom: 12px; display: flex; gap: 16px; align-items: center; }
        .slide-preview { width: 128px; height: 80px; object-fit: cover; border-radius: 4px; flex-shrink: 0; }
        .slide-content { flex: 1; }
        .group-container { background: #343541; border: 2px solid #10a37f; border-radius: 8px; padding: 16px; margin-bottom: 16px; }
        .group-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid #565869; }
        .group-title { font-weight: 600; color: #10a37f; }
        .group-images { display: grid; grid-template-columns: 1fr; gap: 12px; margin-bottom: 12px; }
        .group-image { width: 100%; border-radius: 4px; border: 1px solid #565869; }
        input[type="text"], input[type="number"] { width: 100%; padding: 10px; background: #fff; color: #000; border: 1px solid #565869; border-radius: 6px; font-size: 14px; margin-bottom: 8px; }
        input[type="text"]::placeholder { color: #666; }
        .duration-input { width: 80px; display: inline-block; margin: 0 8px; }
        .btn { padding: 12px 24px; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; display: inline-flex; align-items: center; gap: 8px; transition: all 0.2s; }
        .btn-primary { background: #10a37f; color: white; width: 100%; justify-content: center; }
        .btn-primary:hover { background: #0d8c6d; }
        .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-delete { background: transparent; color: #ef4444; padding: 8px; }
        .btn-delete:hover { color: #dc2626; }
        .settings-group { margin-bottom: 20px; }
        .settings-group label { display: block; margin-bottom: 8px; font-size: 14px; }
        video { width: 100%; border-radius: 8px; margin-bottom: 12px; }
        canvas { display: none; }
        .move-btns { display: flex; flex-direction: column; gap: 4px; }
        .move-btn { background: #565869; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; }
        .move-btn:hover { background: #40414f; }
        .info-text { color: #8e8ea0; font-size: 13px; margin-top: 8px; }
        @media (max-width: 968px) { .main-grid { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <svg class="logo" viewBox="0 0 41 41"><path d="M37.5324 16.8707C37.9808 15.5241 38.1363 14.0974 37.9886 12.6859C37.8409 11.2744 37.3934 9.91076 36.676 8.68622C35.6126 6.83404 33.9882 5.3676 32.0373 4.4985C30.0864 3.62941 27.9098 3.40259 25.8215 3.85078C24.8796 2.7893 23.7219 1.94125 22.4257 1.36341C21.1295 0.785575 19.7249 0.491269 18.3058 0.500197C16.1708 0.495044 14.0893 1.16803 12.3614 2.42214C10.6335 3.67624 9.34853 5.44666 8.6917 7.47815C7.30085 7.76286 5.98686 8.3414 4.8377 9.17505C3.68854 10.0087 2.73073 11.0782 2.02839 12.312C0.956464 14.1591 0.498905 16.2988 0.721698 18.4228C0.944492 20.5467 1.83612 22.5449 3.268 24.1293C2.81966 25.4759 2.66413 26.9026 2.81182 28.3141C2.95951 29.7256 3.40701 31.0892 4.12437 32.3138C5.18791 34.1659 6.8123 35.6322 8.76321 36.5013C10.7141 37.3704 12.8907 37.5973 14.9789 37.1492C15.9208 38.2107 17.0786 39.0587 18.3747 39.6366C19.6709 40.2144 21.0755 40.5087 22.4946 40.4998C24.6307 40.5054 26.7133 39.8321 28.4418 38.5772C30.1704 37.3223 31.4556 35.5506 32.1119 33.5179C33.5027 33.2332 34.8167 32.6547 35.9659 31.821C37.115 30.9874 38.0728 29.9178 38.7752 28.684C39.8458 26.8371 40.3023 24.6979 40.0789 22.5748C39.8556 20.4517 38.9639 18.4544 37.5324 16.8707Z" fill="currentColor"/></svg>
            <h1>ChatGPT Screen to Video Slideshow Maker</h1>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="switchTab('manual')">üì∏ Manual Upload</button>
            <button class="tab" onclick="switchTab('autosplit')">‚úÇÔ∏è Auto-Split Tool</button>
        </div>

        <div id="manualTab" class="tab-content active">
            <div class="main-grid">
                <div>
                    <div class="card">
                        <h2>Upload Images</h2>
                        <label class="upload-area" for="imageUpload">
                            <svg class="upload-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/></svg>
                            <div>Click to upload screenshots</div>
                        </label>
                        <input type="file" id="imageUpload" multiple accept="image/*">
                    </div>
                    <div class="slides-list" id="slidesList"></div>
                </div>
                <div>
                    <div class="card">
                        <h2>Settings</h2>
                        <div class="settings-group">
                            <label>Default Duration (seconds)</label>
                            <input type="number" id="defaultDuration" value="3" min="1" max="10">
                        </div>
                        <button class="btn btn-primary" id="generateBtn">‚ñ∂Ô∏è Generate Video</button>
                    </div>
                    <div class="card" id="previewSection" style="display: none;">
                        <h2>Preview</h2>
                        <video id="videoPreview" controls></video>
                        <button class="btn btn-primary" id="downloadBtn">‚¨áÔ∏è Download Video</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="autosplitTab" class="tab-content">
            <div class="card">
                <h2>How Auto-Split Works</h2>
                <p style="color: #8e8ea0; line-height: 1.6;">
                    1. Upload ChatGPT screenshot(s)<br>
                    2. Click "Split Manually" to mark where to cut<br>
                    3. Each section becomes a separate slide<br>
                    4. Set duration for each group and generate video
                </p>
            </div>
            <div class="main-grid">
                <div>
                    <div class="card">
                        <h2>Upload Screenshot to Split</h2>
                        <label class="upload-area" for="autoSplitUpload">
                            <svg class="upload-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/></svg>
                            <div>Upload ChatGPT screenshot to split</div>
                        </label>
                        <input type="file" id="autoSplitUpload" accept="image/*">
                        <div id="splitPreview" style="margin-top: 20px;"></div>
                    </div>
                    <div class="slides-list" id="groupsList"></div>
                </div>
                <div>
                    <div class="card">
                        <h2>Split Settings</h2>
                        <div class="settings-group">
                            <label>Default Group Duration (seconds)</label>
                            <input type="number" id="groupDuration" value="5" min="1" max="15">
                        </div>
                        <button class="btn btn-primary" id="generateFromGroupsBtn" style="display: none;">‚ñ∂Ô∏è Generate Video</button>
                    </div>
                    <div class="card" id="previewSection2" style="display: none;">
                        <h2>Preview</h2>
                        <video id="videoPreview2" controls></video>
                        <button class="btn btn-primary" id="downloadBtn2">‚¨áÔ∏è Download Video</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        let slides = [], groups = [];
        let currentSplitImage = null;
        let splitMarks = [];

        function switchTab(tabName) {
            document.querySelectorAll('.tab, .tab-content').forEach(t => t.classList.remove('active'));
            if (tabName === 'manual') {
                document.querySelector('.tab:nth-child(1)').classList.add('active');
                document.getElementById('manualTab').classList.add('active');
            } else {
                document.querySelector('.tab:nth-child(2)').classList.add('active');
                document.getElementById('autosplitTab').classList.add('active');
            }
        }

        document.getElementById('imageUpload').addEventListener('change', (e) => {
            Array.from(e.target.files).forEach(file => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    slides.push({ id: Date.now() + Math.random(), image: event.target.result, text: '', duration: parseFloat(document.getElementById('defaultDuration').value) });
                    renderSlides();
                };
                reader.readAsDataURL(file);
            });
        });

        function renderSlides() {
            const list = document.getElementById('slidesList');
            list.innerHTML = '';
            slides.forEach((slide, i) => {
                const div = document.createElement('div');
                div.className = 'slide-item';
                div.innerHTML = `
                    <div class="move-btns">
                        <button class="move-btn" onclick="moveSlide(${i}, -1)" ${i === 0 ? 'disabled' : ''}>‚ñ≤</button>
                        <button class="move-btn" onclick="moveSlide(${i}, 1)" ${i === slides.length - 1 ? 'disabled' : ''}>‚ñº</button>
                    </div>
                    <img src="${slide.image}" class="slide-preview">
                    <div class="slide-content">
                        <input type="text" placeholder="Add text overlay..." value="${slide.text}" onchange="slides[${i}].text=this.value">
                        <div><span style="color:white;font-size:14px">Duration:</span>
                        <input type="number" class="duration-input" value="${slide.duration}" min="1" max="10" onchange="slides[${i}].duration=parseFloat(this.value)">
                        <span style="color:white;font-size:14px">seconds</span></div>
                    </div>
                    <button class="btn btn-delete" onclick="deleteSlide(${i})">üóëÔ∏è</button>
                `;
                list.appendChild(div);
            });
        }

        function moveSlide(i, d) {
            const n = i + d;
            if (n >= 0 && n < slides.length) {
                [slides[i], slides[n]] = [slides[n], slides[i]];
                renderSlides();
            }
        }

        function deleteSlide(i) { slides.splice(i, 1); renderSlides(); }

        document.getElementById('generateBtn').addEventListener('click', async () => {
            if (!slides.length) return alert('Add at least one slide');
            const btn = document.getElementById('generateBtn');
            btn.disabled = true;
            btn.textContent = '‚è≥ Generating...';
            
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            canvas.width = 1280;
            canvas.height = 720;
            
            // Make canvas visible for debugging
            canvas.style.display = 'block';
            canvas.style.border = '2px solid red';
            canvas.style.marginTop = '20px';
            
            const stream = canvas.captureStream(30);
            const recorder = new MediaRecorder(stream, { 
                mimeType: 'video/webm;codecs=vp8',
                videoBitsPerSecond: 2500000 
            });
            const chunks = [];
            
            recorder.ondataavailable = e => {
                if (e.data.size > 0) chunks.push(e.data);
            };
            
            recorder.onstop = () => {
                canvas.style.display = 'none';
                const blob = new Blob(chunks, { type: 'video/webm' });
                document.getElementById('videoPreview').src = URL.createObjectURL(blob);
                document.getElementById('previewSection').style.display = 'block';
                btn.disabled = false;
                btn.textContent = '‚ñ∂Ô∏è Generate Video';
            };
            
            // Pre-load all images first
            const loadedImages = await Promise.all(slides.map(s => {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => resolve({ img, slide: s });
                    img.onerror = () => resolve(null);
                    img.src = s.image;
                });
            }));
            
            recorder.start(100);
            
            // Render each slide multiple times to ensure smooth video
            for (const item of loadedImages) {
                if (!item) continue;
                const { img, slide } = item;
                
                // Calculate fit to canvas while maintaining aspect ratio
                const imgAspect = img.width / img.height;
                const canvasAspect = canvas.width / canvas.height;
                let drawWidth, drawHeight, drawX, drawY;
                
                if (imgAspect > canvasAspect) {
                    // Image is wider
                    drawWidth = canvas.width * 0.95;
                    drawHeight = drawWidth / imgAspect;
                } else {
                    // Image is taller
                    drawHeight = canvas.height * 0.95;
                    drawWidth = drawHeight * imgAspect;
                }
                
                drawX = (canvas.width - drawWidth) / 2;
                drawY = (canvas.height - drawHeight) / 2;
                
                // Draw this slide for its duration
                const framesToDraw = Math.floor(slide.duration * 30);
                for (let frame = 0; frame < framesToDraw; frame++) {
                    // Clear canvas
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw image
                    ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                    
                    // Draw text overlay if exists
                    if (slide.text) {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        ctx.fillRect(0, canvas.height - 100, canvas.width, 100);
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 32px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(slide.text, canvas.width / 2, canvas.height - 50);
                    }
                    
                    // Wait for next frame (30fps = ~33ms)
                    await new Promise(resolve => setTimeout(resolve, 33));
                }
            }
            
            // Wait a bit before stopping
            await new Promise(resolve => setTimeout(resolve, 500));
            recorder.stop();
        });

        function renderSlide(ctx, slide, canvas) {
            return new Promise(resolve => {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    const scale = Math.min(canvas.width / img.width, canvas.height / img.height) * 0.9;
                    const x = (canvas.width - img.width * scale) / 2;
                    const y = (canvas.height - img.height * scale) / 2;
                    ctx.drawImage(img, x, y, img.width * scale, img.height * scale);
                    if (slide.text) {
                        ctx.fillStyle = 'rgba(0,0,0,0.7)';
                        ctx.fillRect(0, canvas.height - 150, canvas.width, 150);
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 48px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(slide.text, canvas.width / 2, canvas.height - 75);
                    }
                    setTimeout(resolve, 100);
                };
                img.onerror = () => {
                    console.error('Image failed to load');
                    resolve();
                };
                img.src = slide.image;
            });
        }

        document.getElementById('downloadBtn').addEventListener('click', () => {
            const a = document.createElement('a');
            a.href = document.getElementById('videoPreview').src;
            a.download = 'slideshow.webm';
            a.click();
        });

        // Auto-Split functionality
        document.getElementById('autoSplitUpload').addEventListener('change', (e) => {
            if (!e.target.files[0]) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                currentSplitImage = event.target.result;
                splitMarks = [];
                const preview = document.getElementById('splitPreview');
                preview.innerHTML = `
                    <div style="position:relative;cursor:crosshair" id="splitImageContainer">
                        <img src="${currentSplitImage}" style="width:100%;border-radius:8px;border:2px solid #565869;display:block;pointer-events:none">
                    </div>
                    <div style="margin-top:12px;color:#8e8ea0;font-size:13px">üëÜ Click on the image where you want to split. You can add multiple split points!</div>
                `;
                setTimeout(() => {
                    document.getElementById('splitImageContainer').addEventListener('click', markSplit);
                }, 100);
            };
            reader.readAsDataURL(e.target.files[0]);
        });

        function markSplit(e) {
            const rect = e.target.getBoundingClientRect();
            const y = ((e.clientY - rect.top) / rect.height) * 100;
            splitMarks.push(y);
            splitMarks.sort((a, b) => a - b);
            updateSplitMarkers();
        }

        function updateSplitMarkers() {
            let html = `<div style="position:relative;cursor:crosshair" id="splitImageContainer">`;
            html += `<img src="${currentSplitImage}" style="width:100%;border-radius:8px;display:block;pointer-events:none">`;
            splitMarks.forEach((y, idx) => {
                html += `<div style="position:absolute;top:${y}%;left:0;right:0;height:3px;background:#10a37f;box-shadow:0 0 5px #10a37f"></div>`;
                html += `<div style="position:absolute;top:${y}%;right:10px;background:#10a37f;color:white;padding:2px 8px;border-radius:4px;font-size:11px;transform:translateY(-50%)">Split ${idx + 1}</div>`;
            });
            html += `</div>`;
            html += `<div style="margin-top:12px;color:#10a37f;font-size:14px;font-weight:600">${splitMarks.length} split mark(s) placed - Click image to add more</div>`;
            html += `<button class="btn btn-primary" onclick="doneSplitting()" style="margin-top:12px">‚úÇÔ∏è Create ${splitMarks.length + 1} Sections</button>`;
            html += `<button class="btn btn-primary" onclick="clearMarks()" style="margin-top:12px;background:#565869">Clear All Marks</button>`;
            document.getElementById('splitPreview').innerHTML = html;
            
            setTimeout(() => {
                document.getElementById('splitImageContainer').addEventListener('click', markSplit);
            }, 100);
        }

        function clearMarks() {
            splitMarks = [];
            const preview = document.getElementById('splitPreview');
            preview.innerHTML = `
                <div style="position:relative;cursor:crosshair" id="splitImageContainer">
                    <img src="${currentSplitImage}" style="width:100%;border-radius:8px;border:2px solid #565869;display:block;pointer-events:none">
                </div>
                <div style="margin-top:12px;color:#8e8ea0;font-size:13px">Click on the image where you want to split. You can add multiple split points.</div>
                <button class="btn btn-primary" onclick="doneSplitting()" style="margin-top:12px;display:none">Done Splitting</button>
                <button class="btn btn-primary" onclick="clearMarks()" style="margin-top:12px;background:#565869;display:none">Clear Marks</button>
            `;
            setTimeout(() => {
                document.getElementById('splitImageContainer').addEventListener('click', markSplit);
            }, 100);
        }

        async function doneSplitting() {
            if (!splitMarks.length) return alert('Please add at least one split mark');
            
            groups = [];
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            
            await new Promise(resolve => {
                img.onload = resolve;
                img.src = currentSplitImage;
            });
            
            canvas.width = img.width;
            canvas.height = img.height;
            
            const positions = [0, ...splitMarks.map(y => (y / 100) * img.height), img.height];
            
            for (let i = 0; i < positions.length - 1; i++) {
                const y1 = positions[i];
                const y2 = positions[i + 1];
                const h = y2 - y1;
                
                const cropCanvas = document.createElement('canvas');
                cropCanvas.width = img.width;
                cropCanvas.height = h;
                const cropCtx = cropCanvas.getContext('2d');
                cropCtx.drawImage(img, 0, y1, img.width, h, 0, 0, img.width, h);
                
                groups.push({
                    id: Date.now() + Math.random(),
                    image: cropCanvas.toDataURL(),
                    duration: parseFloat(document.getElementById('groupDuration').value)
                });
            }
            
            renderGroups();
            document.getElementById('generateFromGroupsBtn').style.display = 'block';
        }

        function renderGroups() {
            const list = document.getElementById('groupsList');
            list.innerHTML = '';
            groups.forEach((g, i) => {
                const div = document.createElement('div');
                div.className = 'group-container';
                div.innerHTML = `
                    <div class="group-header">
                        <div class="group-title">Section ${i + 1}</div>
                        <div class="controls">
                            <button class="move-btn" onclick="moveGroup(${i}, -1)" ${i === 0 ? 'disabled' : ''}>‚ñ≤</button>
                            <button class="move-btn" onclick="moveGroup(${i}, 1)" ${i === groups.length - 1 ? 'disabled' : ''}>‚ñº</button>
                            <button class="btn btn-delete" onclick="deleteGroup(${i})">üóëÔ∏è</button>
                        </div>
                    </div>
                    <div class="group-images"><img src="${g.image}" class="group-image"></div>
                    <div><span style="color:white;font-size:14px">Duration:</span>
                    <input type="number" class="duration-input" value="${g.duration}" min="1" max="15" onchange="groups[${i}].duration=parseFloat(this.value)">
                    <span style="color:white;font-size:14px">seconds</span></div>
                `;
                list.appendChild(div);
            });
        }

        function moveGroup(i, d) {
            const n = i + d;
            if (n >= 0 && n < groups.length) {
                [groups[i], groups[n]] = [groups[n], groups[i]];
                renderGroups();
            }
        }

        function deleteGroup(i) { groups.splice(i, 1); renderGroups(); }

        document.getElementById('generateFromGroupsBtn').addEventListener('click', async () => {
            if (!groups.length) return alert('No groups to generate');
            const btn = document.getElementById('generateFromGroupsBtn');
            btn.disabled = true;
            btn.textContent = '‚è≥ Generating...';
            
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            canvas.width = 1280;
            canvas.height = 720;
            
            canvas.style.display = 'block';
            canvas.style.border = '2px solid red';
            canvas.style.marginTop = '20px';
            
            const stream = canvas.captureStream(30);
            const recorder = new MediaRecorder(stream, { 
                mimeType: 'video/webm;codecs=vp8',
                videoBitsPerSecond: 2500000 
            });
            const chunks = [];
            
            recorder.ondataavailable = e => {
                if (e.data.size > 0) chunks.push(e.data);
            };
            
            recorder.onstop = () => {
                canvas.style.display = 'none';
                const blob = new Blob(chunks, { type: 'video/webm' });
                document.getElementById('videoPreview2').src = URL.createObjectURL(blob);
                document.getElementById('previewSection2').style.display = 'block';
                btn.disabled = false;
                btn.textContent = '‚ñ∂Ô∏è Generate Video';
            };
            
            // Pre-load all images
            const loadedImages = await Promise.all(groups.map(g => {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => resolve({ img, group: g });
                    img.onerror = () => resolve(null);
                    img.src = g.image;
                });
            }));
            
            recorder.start(100);
            
            for (const item of loadedImages) {
                if (!item) continue;
                const { img, group } = item;
                
                // Calculate fit
                const imgAspect = img.width / img.height;
                const canvasAspect = canvas.width / canvas.height;
                let drawWidth, drawHeight, drawX, drawY;
                
                if (imgAspect > canvasAspect) {
                    drawWidth = canvas.width * 0.95;
                    drawHeight = drawWidth / imgAspect;
                } else {
                    drawHeight = canvas.height * 0.95;
                    drawWidth = drawHeight * imgAspect;
                }
                
                drawX = (canvas.width - drawWidth) / 2;
                drawY = (canvas.height - drawHeight) / 2;
                
                const framesToDraw = Math.floor(group.duration * 30);
                for (let frame = 0; frame < framesToDraw; frame++) {
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                    await new Promise(resolve => setTimeout(resolve, 33));
                }
            }
            
            await new Promise(resolve => setTimeout(resolve, 500));
            recorder.stop();
        });

        document.getElementById('downloadBtn2').addEventListener('click', () => {
            const a = document.createElement('a');
            a.href = document.getElementById('videoPreview2').src;
            a.download = 'split-slideshow.webm';
            a.click();
        });
    </script>
</body>
</html>